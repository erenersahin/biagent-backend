"""
Risks API Router

Endpoints for managing risk cards generated by the Risk Agent.
Includes acknowledgment and resolution tracking.
"""

from fastapi import APIRouter, HTTPException
from typing import Optional, List
from pydantic import BaseModel
from datetime import datetime
from enum import Enum

from db import get_db, generate_id
from websocket.manager import broadcast_message


router = APIRouter()


class RiskSeverity(str, Enum):
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class RiskCategory(str, Enum):
    TECHNICAL = "technical"
    SECURITY = "security"
    PERFORMANCE = "performance"
    DEPENDENCY = "dependency"
    TESTING = "testing"
    BLOCKER = "blocker"


class RiskCardCreate(BaseModel):
    """Request to create a risk card (typically from Risk Agent)."""
    pipeline_id: str
    step_id: str
    severity: RiskSeverity
    category: RiskCategory
    title: str
    description: str
    impact: Optional[str] = None
    mitigation: Optional[str] = None
    is_blocker: bool = False


class RiskCardUpdate(BaseModel):
    """Request to update a risk card."""
    severity: Optional[RiskSeverity] = None
    category: Optional[RiskCategory] = None
    title: Optional[str] = None
    description: Optional[str] = None
    impact: Optional[str] = None
    mitigation: Optional[str] = None
    is_blocker: Optional[bool] = None


class RiskAcknowledge(BaseModel):
    """Request to acknowledge a risk."""
    acknowledged_by: str


class RiskResolve(BaseModel):
    """Request to mark a risk as resolved."""
    resolution_notes: str


class RiskCardResponse(BaseModel):
    """Risk card response model."""
    id: str
    pipeline_id: str
    step_id: str
    severity: str
    category: str
    title: str
    description: str
    impact: Optional[str] = None
    mitigation: Optional[str] = None
    is_blocker: bool
    acknowledged: bool
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[str] = None
    resolved: bool
    resolved_at: Optional[str] = None
    resolution_notes: Optional[str] = None
    created_at: str


@router.post("", response_model=RiskCardResponse)
async def create_risk_card(request: RiskCardCreate):
    """Create a new risk card.

    This is called by the Risk Agent when it identifies a risk.
    """
    db = await get_db()

    # Verify pipeline and step exist
    pipeline = await db.fetchone(
        "SELECT * FROM pipelines WHERE id = ?",
        (request.pipeline_id,)
    )
    if not pipeline:
        raise HTTPException(status_code=404, detail="Pipeline not found")

    step = await db.fetchone(
        "SELECT * FROM pipeline_steps WHERE id = ?",
        (request.step_id,)
    )
    if not step:
        raise HTTPException(status_code=404, detail="Step not found")

    now = datetime.utcnow().isoformat()
    risk_id = generate_id()

    await db.execute("""
        INSERT INTO risk_cards (
            id, pipeline_id, step_id, severity, category, title, description,
            impact, mitigation, is_blocker, created_at
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        risk_id,
        request.pipeline_id,
        request.step_id,
        request.severity.value,
        request.category.value,
        request.title,
        request.description,
        request.impact,
        request.mitigation,
        request.is_blocker,
        now
    ))

    await db.commit()

    # Broadcast new risk card
    await broadcast_message({
        "type": "risk_identified",
        "pipeline_id": request.pipeline_id,
        "step": step["step_number"],
        "risk_id": risk_id,
        "severity": request.severity.value,
        "category": request.category.value,
        "title": request.title,
        "is_blocker": request.is_blocker
    })

    return RiskCardResponse(
        id=risk_id,
        pipeline_id=request.pipeline_id,
        step_id=request.step_id,
        severity=request.severity.value,
        category=request.category.value,
        title=request.title,
        description=request.description,
        impact=request.impact,
        mitigation=request.mitigation,
        is_blocker=request.is_blocker,
        acknowledged=False,
        resolved=False,
        created_at=now
    )


@router.get("/pipeline/{pipeline_id}/blockers")
async def get_blocking_risks(pipeline_id: str):
    """Get all blocking risks for a pipeline that are not yet resolved."""
    db = await get_db()

    risks = await db.fetchall("""
        SELECT * FROM risk_cards
        WHERE pipeline_id = ? AND is_blocker = TRUE AND resolved = FALSE
        ORDER BY CASE severity WHEN 'high' THEN 1 WHEN 'medium' THEN 2 ELSE 3 END
    """, (pipeline_id,))

    return {
        "risks": [RiskCardResponse(**dict(r)) for r in risks],
        "has_blockers": len(risks) > 0
    }


@router.get("/{risk_id}", response_model=RiskCardResponse)
async def get_risk_card(risk_id: str):
    """Get a risk card by ID."""
    db = await get_db()

    risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )
    if not risk:
        raise HTTPException(status_code=404, detail="Risk card not found")

    return RiskCardResponse(**dict(risk))


@router.get("/pipeline/{pipeline_id}")
async def get_pipeline_risks(
    pipeline_id: str,
    severity: Optional[RiskSeverity] = None,
    acknowledged: Optional[bool] = None,
    resolved: Optional[bool] = None
):
    """Get all risk cards for a pipeline with optional filters."""
    db = await get_db()

    query = "SELECT * FROM risk_cards WHERE pipeline_id = ?"
    params = [pipeline_id]

    if severity:
        query += " AND severity = ?"
        params.append(severity.value)

    if acknowledged is not None:
        query += " AND acknowledged = ?"
        params.append(acknowledged)

    if resolved is not None:
        query += " AND resolved = ?"
        params.append(resolved)

    query += " ORDER BY CASE severity WHEN 'high' THEN 1 WHEN 'medium' THEN 2 ELSE 3 END, created_at DESC"

    risks = await db.fetchall(query, params)

    return {
        "risks": [RiskCardResponse(**dict(r)) for r in risks],
        "summary": {
            "total": len(risks),
            "high": sum(1 for r in risks if r["severity"] == "high"),
            "medium": sum(1 for r in risks if r["severity"] == "medium"),
            "low": sum(1 for r in risks if r["severity"] == "low"),
            "blockers": sum(1 for r in risks if r["is_blocker"]),
            "unacknowledged": sum(1 for r in risks if not r["acknowledged"]),
            "unresolved": sum(1 for r in risks if not r["resolved"])
        }
    }


@router.patch("/{risk_id}", response_model=RiskCardResponse)
async def update_risk_card(risk_id: str, request: RiskCardUpdate):
    """Update a risk card."""
    db = await get_db()

    risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )
    if not risk:
        raise HTTPException(status_code=404, detail="Risk card not found")

    updates = []
    params = []

    if request.severity is not None:
        updates.append("severity = ?")
        params.append(request.severity.value)

    if request.category is not None:
        updates.append("category = ?")
        params.append(request.category.value)

    if request.title is not None:
        updates.append("title = ?")
        params.append(request.title)

    if request.description is not None:
        updates.append("description = ?")
        params.append(request.description)

    if request.impact is not None:
        updates.append("impact = ?")
        params.append(request.impact)

    if request.mitigation is not None:
        updates.append("mitigation = ?")
        params.append(request.mitigation)

    if request.is_blocker is not None:
        updates.append("is_blocker = ?")
        params.append(request.is_blocker)

    if not updates:
        raise HTTPException(status_code=400, detail="No updates provided")

    params.append(risk_id)

    await db.execute(
        f"UPDATE risk_cards SET {', '.join(updates)} WHERE id = ?",
        params
    )
    await db.commit()

    # Fetch updated record
    updated_risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )

    return RiskCardResponse(**dict(updated_risk))


@router.post("/{risk_id}/acknowledge", response_model=RiskCardResponse)
async def acknowledge_risk(risk_id: str, request: RiskAcknowledge):
    """Acknowledge a risk card.

    Acknowledging indicates that the risk has been reviewed and
    the team is aware of it. This does not mean it's resolved.
    """
    db = await get_db()

    risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )
    if not risk:
        raise HTTPException(status_code=404, detail="Risk card not found")

    if risk["acknowledged"]:
        raise HTTPException(status_code=400, detail="Risk already acknowledged")

    now = datetime.utcnow().isoformat()

    await db.execute("""
        UPDATE risk_cards
        SET acknowledged = TRUE, acknowledged_by = ?, acknowledged_at = ?
        WHERE id = ?
    """, (request.acknowledged_by, now, risk_id))

    await db.commit()

    # Broadcast acknowledgment
    await broadcast_message({
        "type": "risk_acknowledged",
        "pipeline_id": risk["pipeline_id"],
        "risk_id": risk_id,
        "acknowledged_by": request.acknowledged_by
    })

    # Fetch updated record
    updated_risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )

    return RiskCardResponse(**dict(updated_risk))


@router.post("/{risk_id}/resolve", response_model=RiskCardResponse)
async def resolve_risk(risk_id: str, request: RiskResolve):
    """Mark a risk card as resolved.

    The resolution_notes should explain how the risk was addressed.
    """
    db = await get_db()

    risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )
    if not risk:
        raise HTTPException(status_code=404, detail="Risk card not found")

    if risk["resolved"]:
        raise HTTPException(status_code=400, detail="Risk already resolved")

    now = datetime.utcnow().isoformat()

    await db.execute("""
        UPDATE risk_cards
        SET resolved = TRUE, resolved_at = ?, resolution_notes = ?
        WHERE id = ?
    """, (now, request.resolution_notes, risk_id))

    await db.commit()

    # Broadcast resolution
    await broadcast_message({
        "type": "risk_resolved",
        "pipeline_id": risk["pipeline_id"],
        "risk_id": risk_id,
        "resolution_notes": request.resolution_notes
    })

    # Fetch updated record
    updated_risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )

    return RiskCardResponse(**dict(updated_risk))


@router.delete("/{risk_id}")
async def delete_risk_card(risk_id: str):
    """Delete a risk card (admin only)."""
    db = await get_db()

    risk = await db.fetchone(
        "SELECT * FROM risk_cards WHERE id = ?",
        (risk_id,)
    )
    if not risk:
        raise HTTPException(status_code=404, detail="Risk card not found")

    await db.execute("DELETE FROM risk_cards WHERE id = ?", (risk_id,))
    await db.commit()

    return {"status": "deleted", "id": risk_id}
